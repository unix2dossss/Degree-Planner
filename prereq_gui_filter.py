'''
Tkinter Interface manually enter prerequisites "efficiently"
All code in this file is generated by Chat GPT (dirty work)
'''

import tkinter as tk
import json
import sys

with open('initial_cleaned_data.json', 'r') as data_file:
    data = json.load(data_file)

stages = list(data.keys())
current_stage = stages[0]
courses = list(data[current_stage].keys())
current_index = 0
expression = []
current_nested_list = None

def show_current_course():
    course_code = courses[current_index]
    course_info = data[current_stage].get(course_code, {})
    course_name = course_info.get("Name", "Unknown")
    prerequisites = course_info.get("Prerequisite", "No prerequisites")
    course_label.config(text=f"Course: {course_code} - {course_name}")
    prerequisites_label.config(text=f"Prerequisites: {prerequisites}")

def add_course():
    course_code = expression_entry.get()
    if current_nested_list is None:
        expression.append(course_code)
    else:
        current_nested_list.append(course_code)
    expression_entry.delete(0, tk.END)
    update_expression_label()

def update_expression_label():
    expression_label.config(text=f"Expression: {expression}")

def clear_expression():
    global expression, current_nested_list
    expression = []
    current_nested_list = None
    update_expression_label()

def add_nested_list():
    nested_course_code = expression_entry.get()
    nested_expression = [nested_course_code]
    expression.append(nested_expression)
    current_nested_list = nested_expression
    expression_entry.delete(0, tk.END)
    update_expression_label()

def add_to_nested_list():
    course_code = expression_entry.get()
    expression[-1].append(course_code)
    expression_entry.delete(0, tk.END)
    update_expression_label()

def submit_expression():
    if current_stage in data and current_index < len(courses):
        course_code = courses[current_index]
        course_info = data[current_stage].get(course_code, {})
        prereqs = course_info.get("Prereqs", {})
        if len(expression) == 0:
            prereqs["Prereq_Courses"] = None
        else:
            prereqs["Prereq_Courses"] = expression
        expression_entry.delete(0, tk.END)
        update_expression_label()
        print(course_info)  # Print the course dictionary content in the console
        sys.stdout.flush()


def show_next_course():
    global current_index, current_stage, courses, expression
    current_index = (current_index + 1) % len(courses)
    if current_index == 0:
        current_stage = stages[(stages.index(current_stage) + 1) % len(stages)]
        courses = list(data[current_stage].keys())
    show_current_course()
    expression_entry.delete(0, tk.END)

def exit_program():
    json_str = json.dumps(data, indent=4)
    with open("final_cleaned_data.json", "w") as json_file:
        json_file.write(json_str)
    root.destroy()


root = tk.Tk()
root.title("Course Prerequisites")

course_label = tk.Label(root, text="Course:", font=("Arial", 14, "bold"))
course_label.pack()

prerequisites_label = tk.Label(root, text="Prerequisites:", font=("Arial", 12))
prerequisites_label.pack()

next_button = tk.Button(root, text="Next Course", command=show_next_course)
next_button.pack()

expression_label = tk.Label(root, text="Expression: ", font=("Arial", 12))
expression_label.pack()

expression_entry = tk.Entry(root, width=40)
expression_entry.pack()

operators_frame = tk.Frame(root)
operators_frame.pack()

and_button = tk.Button(operators_frame, text="AND", command=add_course)
and_button.pack(side=tk.LEFT)

or_button = tk.Button(operators_frame, text="OR", command=add_to_nested_list)
or_button.pack(side=tk.LEFT)

nested_button = tk.Button(operators_frame, text="[ ]", command=add_nested_list)
nested_button.pack(side=tk.LEFT)

submit_button = tk.Button(root, text="Submit", command=submit_expression)
submit_button.pack()

clear_button = tk.Button(root, text="Clear", command=clear_expression)
clear_button.pack()

exit_button = tk.Button(root, text="Exit", command=exit_program)
exit_button.pack()

show_current_course()

root.mainloop()